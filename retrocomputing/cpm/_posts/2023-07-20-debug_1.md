---
layout: post
title:  "Дебагери для CP/M та Osborne Executive"
date:   2023-07-20 1:23:45 +0300
tags: [CP/M, retrocomputing, asm, Z80, i8080, debugger]
categories: [retrocomputing, CP/M]
comments: true
excerpt_separator: <!--more-->
---

- [SID -- Symbolic debugger]({% post_url /retrocomputing/cpm/2023-07-20-debug_1 %}#sid--symbolic-debugger)
- [DDT -- Dynamic debugging tool]({% post_url /retrocomputing/cpm/2023-07-20-debug_1 %}#ddt--dynamic-debugging-tool)
- [Виноски](#виноски)

[T](#sid----symbolic-debugger)

Короткий огляд дебагерів, з якими зіткнувся, поки експериментував із [асемблерами]({% post_url /retrocomputing/cpm/2023-07-19-asm_1 %}) -- не прагнучи до повноти.

<style>body {text-align: justify}</style>

<!--more-->

# SID -- Symbolic debugger

Цей [дебагер](/retrocomputing/cpm/files/SID_ZSID.pdf) виявився, враховуючи епоху, на диво потужним.

Вміє завантажувати, поміж іншого, .COM та .HEX файли[^HX].

[^HX]: Враховуючи, що багато інструментів CP/M генерують саме HEX-файли, які потрім потрібно конвертувати -- корисна можливість.

> Представляється SID, що йде із Osborne Executive як ``CP/M 3 SID - Version 3.0``, всередині має стрічку ``CP/M Version 3.0COPYRIGHT 1982, DIGITAL RESEARCH``. Розмір -- 7936 байт.

Завантаження -- або так:

```bat
SID HEZ80.COM
```

або інтерактивно:

```bat
D0>sid
CP/M 3 SID - Version 3.0
# E HEZ80.COM
```

Подивитися вміст пам'яті: ``D`` -- по байтах, ``DW`` -- по словах, ``D<addr>`` -- починаючи з цієї адреси, ``D<from>,<to>`` -- у вказаному інтервалі.

```text
#D100,120
0100: 0E 09 11 09 01 CD 05 00 C9 0D 0A 48 65 6C 6C 6F ...........Hello
0110: 2C 20 57 6F 72 6C 64 21 0D 0A 24 00 00 00 00 00 , World!..$......
0120: 00                                              .
```

``A<addr>`` -- асемблювати. Не знає про Z80, і досить жорсткий щодо формату -- пробілів між операндами не розуміє, числа -- в HEX за замовчуванням, щоб в десятковій -- спереду ставиться #, але можна використовувати як малі, так і великі літери. 

```nasm
#A100
0100  ld C,09
?
0100  mvi c,09
0102  mvi c, 09
?
#a
0102  mvi  c,09
0104  mvi c,#10
0106  mvi     C,10
0108
```

``G`` -- виконувати, має багато варіантів. ``G,<to>`` -- створює тимчасову точку зупинки (breakpoint) за адресою ``to``, виконується з поточного PC. ``G<from>,<to>`` -- те ж, але розпочинає з ``from``. Інші варіанти -- див. документацію[^SIDDOC].

[^SIDDOC]: [SID manual](/retrocomputing/cpm/files/SID_ZSID.pdf).

``S<addr>`` -- записати значення в пам'ять побайтово, ``SW<addr>`` -- по словах. Окрім числових значень, можна передати ``"text string`` (зауважте -- лапки тільки на початку, далі їх просто зберігатиме в пам'ять). Завершити -- ``.``, або невірний ввід.

``T`` -- Trace, виконати команду, ``TW`` -- те ж, але не заходити у функції. ``T5`` -- виконати 5 команд:
```
#t5
 ----- A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI  C,09
 ----- A=00 B=0009 D=0000 H=0000 S=0100 P=0102 LXI  D,0109
 ----- A=00 B=0009 D=0109 H=0000 S=0100 P=0105 CALL 0005
 ----- A=00 B=0009 D=0109 H=0000 S=00FE P=0005 JMP  E200
 ----- A=00 B=0009 D=0109 H=0000 S=00FE P=E200 JMP  E8A4
*E8A4
#T
 ----- A=00 B=0009 D=0109 H=0000 S=00FE P=E8A4 XTHL
*E8A5
#T
 ----- A=00 B=0009 D=0109 H=0108 S=00FE P=E8A5 SHLD FBF2
*E8A8
#T
 ----- A=00 B=0009 D=0109 H=0108 S=00FE P=E8A8 XTHL
*E8A9
```

``X`` -- вивести стан процесора:
```
#X
 ----- A=00 B=0009 D=011B H=0000 S=0100 P=0108 RET
```

``X<reg-or-flag>`` -- переглянути або змінити регістр чи прапорець. Прапорці вказуються кодами C,Z,M,E, I, регістри -- A,B,D,H,S та P. 

```
#XA
A=00 5
#X
 ----- A=05 B=0009 D=011B H=0000 S=0100 P=0108 RET
```

``P<addr>[,count]`` -- ``pass point``, встановити точку зупинки (breakpoint). Додатково можна вказати -- на якій ітерації зупинитися. Зупиняється на команді **після** тієї, якої стосується точка зупинки.

``W<filename>,<from>,<to>`` -- записати вміст пам'яті у файл.


Інші команди:
- ``F<from>,<to>,<byte>`` -- заповнити байтом.
- ``С<addr>`` -- викликати підпрограму. ``C<addr>[,<BC>[,DE]]`` -- встановлює відповідні пари регістрів перед викликом.
- ``H<a>,<b>`` -- обчислює суму та різницю a i b.
- ``L[<from>,<to>]`` -- вивести дизасембльований код за вказаними адресами.
- ``M<block_start>,<block-end>,<dest>`` -- копіює (Move) блок пам'яті.
- Підтримує своєрідні плагіни -- Utility. В комплект входить, наприклад, HIST -- побудова гістограми частоти виконання фрагментів програми. Детальніше -- див. документацію.
  -  ``U`` -- команда, аналогічна ``T``, не виводить регістри, але дозволяє працювати утилітам.  

# DDT -- Dynamic debugging tool

Це старіший, більш простий, але, в цілому -- схожий на SID, зневаджувач. Місцями, більш ''заморочений'', скажімо -- завантажити програму включає виконати команду I, а поті ще R -- read. Подробиці -- див. документацію[^DDTDOC].

```
D0>ddt hez80.com
DDT VERS 2.2
NEXT  PC
0180 0100
-t
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI  C,09*0102
-t
C0Z0M0E0I0 A=00 B=0009 D=0000 H=0000 S=0100 P=0102 LXI  D,0109*0105
-t
C0Z0M0E0I0 A=00 B=0009 D=0109 H=0000 S=0100 P=0105 CALL 0005*0005
-g

Hello, World!

<Зависає>

D0>ddt
DDT VERS 2.2
-ihez80.com
-R
NEXT  PC
0180 0100
-t5
C0Z0M0E0I0 A=00 B=0000 D=0000 H=0000 S=0100 P=0100 MVI  C,09
C0Z0M0E0I0 A=00 B=0009 D=0000 H=0000 S=0100 P=0102 LXI  D,0109
C0Z0M0E0I0 A=00 B=0009 D=0109 H=0000 S=0100 P=0105 CALL 0005
C0Z0M0E0I0 A=00 B=0009 D=0109 H=0000 S=00FE P=0005 JMP  ED00
C0Z0M0E0I0 A=00 B=0009 D=0109 H=0000 S=00FE P=ED00 JMP  F3A2*F3A2
-G,109
⌂
Hello, World!

<Зависає>
```


[^DDTDOC]: [DDT USER'S GUIDE](/retrocomputing/cpm/files/DDT.pdf).


# Виноски

