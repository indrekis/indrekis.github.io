---
layout: post
title:  "RunCPM -- емулятор узагальненої CP/M-системи"
date:   2023-07-14 7:23:45 +0300
tags: [CP/M, retrocomputing]
categories: [retrocomputing, CP/M]
comments: true
excerpt_separator: <!--more-->
---


# RunCPM

Існують емулятори конкретних систем, на яких можна виконувати код CP/M, портованих для них. Але існують і генералізовані емулятори, що дозволяють працювати з CP/M безпосередньо, емулюючи тим чи іншим способом диски та інші засоби комунікації з залізом. 

Вони дуже корисні для розробки під цю ОС. 

Не претендуючи на повноту охоплення, після тривалих пошуків і випробування кількох варіантів, зупинився на [RunCPM](https://github.com/MockbaTheBorg/RunCPM).


<!--more-->

<style>body {text-align: justify}</style>

- Open source. ''З коробки'' скомпілювалася зразу.
- Для емуляції дисків використовує директорії хостової ОС, з іменами A, B, C тощо, де директорії з іменами 0, 1, ..., 15, відповідають файлам користувачів із такими номерами. Це доволі зручно! 
- Підтримує Arduino -- може бути основою емуляторів з апаратною складовою, але сам я цього не перевіряв.
- Підтримується друк, буде відбуватися у файл LST.TXT (або PUN.TXT).
- Підтримує скриптування за допомогою [LUA](http://indrekis2.blogspot.com/2011/12/lua.html)! (Не на Arduino).
- Підтримується CP/M 2.2, 3.0 обіцяють з часом, але поки ще ні.
- Термінал -- ANSI/VT100.
- Емуляція дисків, природно, неточна, не підтримуються атрибути.
- Також, автор ділиться своєю [колекцією софта для CP/M](https://drive.google.com/drive/folders/11WIu8rD_7pIDaET7dqTeA73CvX0jkxz2), вже підготовленою для роботи з емулятором.


Директорії із дисками шукає у тій директорії, де лежать виконавчий файл емулятора. 

Системні файли знаходяться в A.ZIP. Також, A.ZIP містить багато цікавих утиліт, аж по [TE.COM].
<!-- додати лінк на пост про нього -->

Підтримує кілька варіантів [CCP](https://en.wikipedia.org/wiki/CP/M#Console_Command_Processor) -- командних інтерпретаторів, включаючи ZCP -- вибір здійснюється під час компіляції, за допомогою файлу globals.h:
```C
/* Definition of which CCP to use (must define only one) */
#define CCP_INTERNAL // If this is defined, an internal CCP will emulated
//#define CCP_DR
//#define CCP_CCPZ
//#define CCP_ZCPR2
//#define CCP_ZCPR3
//#define CCP_Z80
```

Там також можна включити підтримку LUA:
```C
#define HASLUA	
```

Після перекомпіляції можна забрати виконавчий файл емулятора директорії RunCPM/CCP.

Компілював під Windows з використанням MSYS2/MinGW64:

```bash
$ git clone https://github.com/MockbaTheBorg/RunCPM
$ cd RunCPM
$ make mingw build 
```
Отриманий RunCPM.exe можна скопіювати, куди зручно -- від DLL MinGW64 він не залежить. 

Далі потрібно у тій директорії створити директорії A, B тощо -- скільки потрібно. В A/0 -- розархівувати вміст RunCPM/DISK/A.ZIP, і можна запускати. Виглядає це так: 

![](/retrocomputing/cpm/pics/runcpm_scr.png)

![](/retrocomputing/cpm/pics/runcpm_lua_scr.png)

Багато скріншотів будуть також в розділі [''Текстовий редактор'']({% post_url /retrocomputing/cpm/2023-07-18-te_1 %}) -- використовував для компіляції цього редактора.

Компіляція за допомогою MS Visual Studio підтримується, але я не випробовував. 

Вихід -- за допомогою EXIT.COM.
